# nginx为什么能够替代httpd发展起来

[TOC]

nginx为什么能够在httpd如日中天的时候发展起来,并且不断蚕食其市场份额?

> 它免费,开源,并且高性能代练httpd的请求,最重要的是因为c10k

什么是c10k

> 现在互联网发展迅速,高访问量和高并发量成为新常态,传统的httpd并不能够解决这样的问题,c10k页就是concurrent 10 000 connection 由于硬件成本降低,如果一台服务器能够服务更多客户端那就更加合算了,httpd显然自己在这个方面没有这样的优势

为什么说httpd没有这样的优势

> httpd有三种MPM
>
> prefork：进程模型，两级结构，主进程master负责生成子进程，每个子进程负责响应一个请求
>
> worker：线程模型，三级结构，主进程master负责生成子进程，每个子进程负责生成多个线程，每个线程响应一个请求
>
> event：主进程master负责生成子进程，每个子进程响应多个请求
>
> 
>
> httpd在处理请求的时候是这样的:比如perfork模型,每个子进程响应一个请求,为什么只能响应一个请求呢?那是因为一个进程在io是阻塞的,它在等待数据到来才能回复,如果一直不回复就只能等待,在等待期间不能去接受其他的请求,这个时候就被阻塞了,而且perfork每个子进程接受的请求有限,不光这样,系统调用,进程创建,进程销毁都要消耗时间,
>
> httpd不管用那个模型都不能避免在io的过程中浪费时间和资源,不能很好的利用

上面的io模型是什么

> 阻塞型、非阻塞型、复用型、信号驱动型、异步
>
> 一次IO请求，都会由两阶段组成
>
> 1. 第一步：等待数据，即数据从磁盘到内核内存
> 2. 第二步：复制数据，即数据内核内存到进程内存
>
> 阻塞/非阻塞(关注调用者在等待结果返回之前所处的状态)
>
> - 阻塞：blocking，调用结果返回之前，调用者被挂起
> - 非阻塞：nonblocking，调用结果返回之前，调用者不会被挂起
>
> 同步/异步(关注消息通知机制)
>
> - 同步：等待对方返回消息
> - 异步：被调用者通过状态、通知或回调机制通知调用者被调用者的运行状态
>
> 复用型IO调用
>
> ​	可以在阻塞之前能够接入更多的请求,能够同时监控这些请求数据是否准备好,主要用的是select(),这个函数调用可以同时监控多达1024个请求,poll()函数调用也可以完成
>
> event-driven
>
> epoll（Linux）：libevent
>
> Kqueue（BSD）
>
> Solaris：/dev/poll
>
> 具体的可以看我另外一个博客

nginx有什么优势

> 他实现了一个子进程可以同时接入多个请求,而且优化了io模型等等,
>
> 总之三个优势 
>
> - event-driven
> - asynchronous
> - non-blocking

